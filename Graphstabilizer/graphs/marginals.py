#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Tue May 16 17:40:25 2023

@author: jarn
"""
# Global imports
# from numpy.linalg import matrix_rank
from numpy import ix_, zeros, ones

from numpy import ndarray, log2

from numpy import hstack

from numpy import round as npround

from numpy.linalg import eigvalsh

from itertools import combinations_with_replacement, permutations, product, combinations

from galois import GF


# Local imports
from Graphstabilizer.states import Graphstate
from Graphstabilizer.graphs.elementary import get_AdjacencyMatrix_from_edgelist, AdjacencyMatrix
from Graphstabilizer.graphs.graphstyles import GraphStyle
from Graphstabilizer.graphs.graphstyles import metawhiteonblack, metablackonwhite

from Graphstabilizer.binary.linAlg import get_rank

from Graphstabilizer.graphs.drawing import prepare_graphstatedrawing, draw_nodes, draw_edges, calculate_axes_limits

from Graphstabilizer.checkers.elementary import check_is_node_index, check_is_Boolvar

field = GF(2)

def marginal_rank(graphstate: Graphstate, M: tuple):
    '''
    For a given graph state G, its marginal on the set M is tr_C[G], with C the complement of M. 
    
    This function returns the rank of the reduced density matrix, which is a power of two, 
    starting from 2^0 (for pure reduced states) until 2^Ms with Ms the size of the marginal, for completely mixed marginals.
    
    The rank of the marginal has to do with the number of elements in the reduced stabilizer, by an inverse proportion.
    
    The number of elements in the reduced stabilizer is 2^b_m, where b_m is the dimension of the nullspace of the matrix A_{M,C}, 
    i.e. the lower left block of the blockmatrix A, the adjacency matrix:
    
    A = [ A_{M,M} | A_{C,M} ]
        [ A_{M,C} | A_{C,C} ]
        
    Where it is implied w.l.o.g. that M are the first nodes. (The function itself actually doesn't assume this)
    The function calculates the nullity as abs(M) - rank(A_{M,C}) by the rank-nullity theorem
    
    The rank of the marginal is then exactly 2**(abs(M) - b_m) = 2**rank(A_{M,C})                                                          
                                                              
    '''
    # Remove double items from M
    M = tuple(set(M))
    Mc = tuple(a for a in range(graphstate.nr_qubits) if a not in M)

    # rank = matrix_rank(graphstate.adj.get_matrix()[ix_(Mc, M)])
    rank = get_rank((graphstate.adj.get_matrix()[ix_(Mc, M)]))
    
    return int(2**(rank))

def marginal_nullspace_rank_after_Z(graphstate: Graphstate, M: tuple, k: int):
    '''
    Obtain the rank of the marginal state 
    '''
    
    Mc = tuple(a for a in range(graphstate.nr_qubits) if a not in M + (k,))
    
    # rank = matrix_rank(graphstate.adj.get_matrix()[ix_(Mc, M)])
    rank = get_rank((graphstate.adj.get_matrix()[ix_(Mc, M)]))
    
    return 2**(rank)

def marginal_dimension(graphstate: Graphstate, M: tuple):
    '''
    The dimension is the base-2 log of the number of elements in the reduced stabilizer. 
    That makes it abs(M) - log(rank). See marginal_rank for more details.
    '''
    # Remove double items from M
    M = tuple(set(M))
    
    Mc = tuple(a for a in range(graphstate.nr_qubits) if a not in M)
    
    
    return field(graphstate.adj.get_matrix()[ix_(Mc, M)]).null_space().shape[0]

def get_original_vector(graphstate, M, basis_element):
    '''
    Return the original bit-representation of the Pauli associated with the graphstate G,
    for a selection of marginal M and selection of nodes in M given by basis_element.
    '''
    
    vector = zeros((graphstate.nr_qubits * 2, 1), dtype = 'int')
    
    for index, value in zip(M, basis_element):        
        # Add X element
        vector[index, 0] = int(value)
        # Add Z elements
        vector[graphstate.nr_qubits:] += int(value) * graphstate.adj.get_matrix()[:, index]
    
    return vector % 2

def surviving_element_basis(graphstate: Graphstate, M: tuple):
    '''
    Obtain bit-representations of the surviving elements of the reduced stabilizer. 
    Only returns the basis elements, from which an arbitrary (binary) linear combination can be build.
    So returns exactly marginal_dimension(G, M) elements.
    '''
    # Remove double items from M
    M = tuple(set(M))
    
    Mc = tuple(a for a in range(graphstate.nr_qubits) if a not in M)
    
    
    basis = field(graphstate.adj.get_matrix()[ix_(Mc, M)]).null_space()
    
    surviving = []
    for v in basis:
        surviving.append(get_original_vector(graphstate, M, v))
    
    return surviving


#%% Interesting marginals
def interestingness_marginal(graphstate: Graphstate, M: tuple):
    '''
    A marginal is interesting if there are more elements in its reduced stabilizer (LHS) than
    there are elements in the group generated by all the reduced stabilizers of is submarginals (RHS).
    Returns |LHS|/|RHS|, which can be either 0,1 or 2.
    '''
    dim = marginal_dimension(graphstate, M)
    
    if dim < 1:
        return dim
    
    RHS = []
    for subset in combinations(M, r = len(M) - 1):
        # print(subset)
        compl = tuple(a for a in range(graphstate.nr_qubits) if a not in subset)
        
        N = field(graphstate.adj.get_matrix()[ix_(compl, subset)]).null_space()
        # Ns.append(N)
        
        for v in N:
            RHS.append(get_original_vector(graphstate, subset, v))
    
    if len(RHS) == 0:
        return dim        
    
    K = field(hstack(RHS))
    
    return dim + K.null_space().shape[0] - K.shape[1]

def marginal_is_MLS(graphstate: Graphstate, M: tuple):
    '''
    A marginal is a MLS (minimal local set) if its dimension is not 0 and if the dimensions of all its submarginals are 0.
    We know that this is either 0,1 or 2.
    Returns 'False' or 'True'
    '''
    dim = marginal_dimension(graphstate, M)
    
    if dim < 1:
        return False
    
    for subset in combinations(M, r = len(M) - 1):
        # print(subset)
        if marginal_dimension(graphstate, subset) != 0:
            return False

    return True    

def marginals_is_type1MLS(graphstate: Graphstate, M: tuple):
    '''
    A type one MLS has dimension 1 in addition to being an MLS.
    '''
    dim = marginal_dimension(graphstate, M)
    if dim != 1:
        return False
    if marginal_is_MLS(graphstate, M):
        return True
    else: return False
        
    
def marginals_is_type2MLS(graphstate: Graphstate, M: tuple):
    '''
    A type one MLS has dimension 1 in addition to being an MLS.
    '''
    dim = marginal_dimension(graphstate, M)
    if dim != 2:
        return False
    if marginal_is_MLS(graphstate, M):
        return True
    else: return False

#%% 2-body meta-graph
class MetaGraphTwo:
    '''
    Initialize a 2-body MetaGraph. It can be initialized from a given 
    '''
    def __init__(self, M:tuple = (0,1), G: Graphstate  = None, N = None, identifier = None, Graphstyletemplate = metawhiteonblack, labels = None):
        # If G is None we try to init from the N list
        self.Marginal = M
                
        if G is None:
            if labels is None:
                from Graphstabilizer.graphs.metagraphs.bi import node_labels
                labels = node_labels
            if N is None:
                if identifier is None:
                    raise ValueError("Provide either a Graphstate, the neighbourhoods of marginal nodes, or an identifier,")
                elif identifier is not None:
                    self.Metagraph, self.Graphstyle,  = self.init_from_identifier(identifier, Graphstyletemplate, labels)
                self.Metaneighours_as_dict = None
            # Now N is a list
            elif N is not None:
                self.Metagraph, self.Graphstyle,  = self.init_from_marginal_neighbours(N, Graphstyletemplate, labels)
                self.Metaneighours_as_dict = N
            
            # The marginal is by default now [0,1,2]
            
            
            
        
        # Now G is a Graphstate so we initialize from this Graphstate
        else:
            assert len(M) == 2, f"Warning, provided marginal {M} has {len(M)} entries instead of 2."
            if labels is None:
                labels = [str(M[0]),str(M[1]), str(M[0]) + str(M[1])]
            for node in M:
                assert check_is_node_index(size = G.nr_qubits, node = node, raiseorFalse = 'false'), f"Warning, marginal {M} with entry {node} is not contained in graph G with {G.nr_qubits} nodes."
            self.Metagraph, self.Graphstyle, self.Metaneighours_as_dict = self.init_from_Graphstate(G, M, Graphstyletemplate, labels)
            self.Marginal = M
        # self.Graphstyle.set_nodes_radii(self.Graphstyle.get_node_radius(0)*0.9, [3,4,5,6,7,8,9])
        
        self.Origingraphstate = G
        
    #%% Meta-operations
    def map_metaneighbours_zero(self):
        '''
        Remove all connections between outside metaneighbours that might have been created.
        '''
        A = self.Metagraph.adj.get_matrix()
        A[ix_(range(2,5),range(2,5))] = zeros((3,3), dtype = 'int')
        self.Metagraph = Graphstate(graph = AdjacencyMatrix(A), 
                                    node_labels = self.Metagraph.node_labels, 
                                    node_positions = self.Metagraph.node_positions, 
                                    graphstyle = self.Metagraph.graphstyle)
    
    def local_complementation_internal(self, node):
        '''
        Perform a local complementation on the given internal node.
        '''
        assert node in [0,1], f"Warning, not an internal node given. Node provided is {node} but should be 0 or 1"
        
        # Perform local complementation
        self.Metagraph.local_complement(node)
        
        # Map out edges to zero
        self.map_metaneighbours_zero()
        
        # Return a new Metagraph
        NewMeta =  MetaGraphTwo(G = self.Metagraph, M = self.Marginal)
        
        self.Metagraph = NewMeta.Metagraph
    
    #%% Info functions
    @property
    def metaneighbours_as_list(self):
        '''
        '''
        if self.Origingraphstate is None:
            raise ValueError("No original graphstate, so no original metaneighbours.")
        
        return [self.Metaneighours_as_dict['Na'],
                self.Metaneighours_as_dict['Nb'],
                self.Metaneighours_as_dict['Nab']]
        
    @property
    def metagraph_rank(self):
        '''
        The rank of the marginal, i.e. the rank of the metagraph in the original graph.
        '''
        return marginal_rank(self.Metagraph, M = (0,1))
    
    def get_number_of_populated_metaneighbours(self) -> int:
        '''
        Obtain the number of metaneighbours that are populated, i.e. that are connected to the marginal.
        '''
        nr_metaneighbours = 0
        
        for single in [2,3]:
            nr_metaneighbours += len(self.Metagraph.get_neighbourhood(single))
        for double in [4]:
            nr_metaneighbours += len(self.Metagraph.get_neighbourhood(double))/2
        
        assert nr_metaneighbours == int(nr_metaneighbours), f"{nr_metaneighbours} is not an int."
        
        return int(nr_metaneighbours)
        
    #%% Drawing functions
    def draw(self, axis = None, fig = None, updateaxeslimits = True):
        '''
        Draw the metagraph in the given axis. If no axis is given, create a new figure and axis.
        Returns the figure and axis.
        '''
        if axis is None:
            fig, axis = prepare_graphstatedrawing(self.Graphstyle)
        
        if updateaxeslimits:
            xlim, ylim = calculate_axes_limits(self.Graphstyle)
            axis.set_xlim(xlim)
            axis.set_ylim(ylim)
        
        draw_nodes(Graphstyle = self.Graphstyle, axis = axis)
        
        draw_edges(Graphstate = self.Metagraph, Graphstyle = self.Graphstyle, axis = axis)
        
        return fig, axis
        
    #%% Init functions    
    def init_from_marginal_neighbours(self, N: list, Graphstyletemplate, labels):
        '''
        Obtain the 3-body Metagraph for a given list of neighbours of the marginal,
        i.e. Na, Nb and Nc, where these are the complete neighbourhoods.
        '''
        a_N = set(N[0])
        b_N = set(N[1])
        
        ab = 1 in a_N

        
        Na = a_N - b_N
        Nb = b_N - a_N
        
        Nab = a_N & b_N 

                
        # First the inner edges
        identifier = ''.join(['1' if edge else '0' for edge in [ab]])
        
        # Then the outer edges
        identifier += ''.join(['1' if len(neigh) > 0 else '0' for neigh in [Na, Nb, Nab]])
        
        return self.init_from_identifier(identifier, Graphstyletemplate, labels)
        
    
    # def init_from_identifier(self, identifier: str, Graphstyletemplate, labels):
    #     '''
    #     Obtain the 2-body marginal Metagraph from an identifier. See Metagraph.identifier for information.
    #     '''
    #     # Import
    #     from Graphstabilizer.graphs.metagraphs.tri import pos, potential_inner_edges, potential_single_edges, potential_double_edges, potential_triple_edges
        
    #     # Create an edgelist and fill based on the identifier
    #     edgelist = []
        
    #     # First the inner edges
    #     for i in range(2):
    #         # Inner edges
    #         if identifier[i] == '1':
    #             edgelist.append(potential_inner_edges[i])
    #         # Single edges
    #         if identifier[i+3] == '1':
    #             edgelist.append(potential_single_edges[i])
    #         # Double edges
    #         if identifier[i+6] == '1':
    #             edgelist.extend(potential_double_edges[i])
        
    #     # Triple edge
    #     if identifier[-1] == '1':
    #         edgelist.extend(potential_triple_edges[0])
    
        
        
    #     adj = get_AdjacencyMatrix_from_edgelist(5,edgelist)
        
    #     G = Graphstate(graph = adj)
    #     graphstyle = GraphStyle(nr_nodes = 5, template = Graphstyletemplate, node_labels = labels, node_positions = pos)
    #     return G, graphstyle
        
    
    def init_from_Graphstate(self, G: Graphstate, M: list, Graphstyletemplate, labels):
        '''
        Obtain the 2-body Metagraph for a given Graphstate on the marginal M containing 2 nodes of G.
        '''
        # Imports
        from Graphstabilizer.graphs.metagraphs.bi import potential_single_edges, potential_double_edges, pos
        
        
        
        # Sort M in ascending order and get the complement C
        if type(M) == tuple:
            M = list(M)
        # M.sort()
        Mc = tuple(a for a in range(G.nr_qubits) if a not in M)
            
        
        # Initialize the meta neighbourhoods
        # a, b, c = [], [], []
        Na, Nb, Nab, Ne = [], [], [], []
        
        # Fill the meta neighbourhoods
        # First the inner nodes
        
        
        # Then the outer nodes
        for node in Mc:
            # row = G.adj.get_matrix()[ix_([node], M)]
            
            in_a = False
            in_b = False
            
            
            if node in G.get_neighbourhood(M[0]):
                in_a = True
            if node in G.get_neighbourhood(M[1]):
                in_b = True

            
            
            
            if not in_a and not in_b:
                Ne.append(node)
            elif in_a and not in_b:
                Na.append(node)
            elif not in_a and in_b:
                Nb.append(node)
            elif in_a and in_b:
                Nab.append(node)
        
        
        # Obtain the edges of the metagraph
        edgelist = []
        # First the inner edges
        a_neighbourhood = G.get_neighbourhood(M[0])
        
        if M[1] in a_neighbourhood:
            edgelist.append((0,1))
    
        
        # Then the outer edges
        if len(Na) >= 1:
            edgelist.append(potential_single_edges[0])
        if len(Nb) >= 1:
            edgelist.append(potential_single_edges[1])
        if len(Nab) >= 1:
            edgelist.extend(potential_double_edges[0])

        
        # Create the metagraph
        adj = get_AdjacencyMatrix_from_edgelist(5,edgelist)
        
        G = Graphstate(graph = adj)
        graphstyle = GraphStyle(nr_nodes = 5, template = Graphstyletemplate, node_labels = labels, node_positions = pos)
        return G, graphstyle, {'Na' : Na, 'Nb' : Nb, 'Nab' : Nab }
    
    #%% Info functions
    @property
    def identifier(self):
        '''
        Get the identifier for the metagraph. This is a 10-bit string, with every entry being 0 or 1 if that (meta)-edge is connected to or not.
        This starts with the internal edges, and subsequently the 7 outside neighbors are added.
        '''
        
        ## First the internal edges
        identifier = ['1' if edge else '0' for edge in [self.Metagraph.contains_edge(0,1)]]
        
        ## Then the external edges
        identifier.extend(['1' if len(self.Metagraph.get_neighbourhood(index)) >= 1 else '0' for index in range(2,5)])
        
        return ''.join(identifier)
        
#%% 3-body meta-graph
class MetaGraphThree:
    '''
    Initialize a 3-body MetaGraph. It can be initialized from a given 
    '''
    def __init__(self, M:tuple = (0,1,2), G: Graphstate  = None, N = None, identifier = None, Graphstyletemplate = metawhiteonblack, labels = None):
        # If G is None we try to init from the N list
        self.Marginal = M
                
        if G is None:
            if labels is None:
                from Graphstabilizer.graphs.metagraphs.tri import node_labels
                labels = node_labels
            if N is None:
                if identifier is None:
                    raise ValueError("Provide either a Graphstate, the neighbourhoods of marginal nodes, or an identifier,")
                elif identifier is not None:
                    self.Metagraph, self.Graphstyle,  = self.init_from_identifier(identifier, Graphstyletemplate, labels)
                self.Metaneighours_as_dict = None
            # Now N is a list
            elif N is not None:
                self.Metagraph, self.Graphstyle,  = self.init_from_marginal_neighbours(N, Graphstyletemplate, labels)
                self.Metaneighours_as_dict = N
            
            # The marginal is by default now [0,1,2]
            
            
            
        
        # Now G is a Graphstate so we initialize from this Graphstate
        else:
            assert len(M) == 3, f"Warning, provided marginal {M} has {len(M)} entries instead of 3."
            if labels is None:
                labels = [str(M[0]),str(M[1]), str(M[2]), str(M[0]) + str(M[1]), str(M[1]) + str(M[2]), str(M[0]) + str(M[2]), str(M[0]) + str(M[1]) + str(M[2])]
            for node in M:
                assert check_is_node_index(size = G.nr_qubits, node = node, raiseorFalse = 'false'), f"Warning, marginal {M} with entry {node} is not contained in graph G with {G.nr_qubits} nodes."
            self.Metagraph, self.Graphstyle, self.Metaneighours_as_dict = self.init_from_Graphstate(G, M, Graphstyletemplate, labels)
            self.Marginal = M
        # self.Graphstyle.set_nodes_radii(self.Graphstyle.get_node_radius(0)*0.9, [3,4,5,6,7,8,9])
        
        self.Origingraphstate = G
        
    #%% Meta-operations
    def map_metaneighbours_zero(self):
        '''
        Remove all connections between outside metaneighbours that might have been created.
        '''
        A = self.Metagraph.adj.get_matrix()
        A[ix_(range(3,10),range(3,10))] = zeros((7,7), dtype = 'int')
        self.Metagraph = Graphstate(graph = AdjacencyMatrix(A), 
                                    node_labels = self.Metagraph.node_labels, 
                                    node_positions = self.Metagraph.node_positions, 
                                    graphstyle = self.Metagraph.graphstyle)
    
    def local_complementation_internal(self, node):
        '''
        Perform a local complementation on the given internal node.
        '''
        assert node in [0,1,2], f"Warning, not an internal node given. Node provided is {node} but should be 0,1 or 2"
        
        # Perform local complementation
        self.Metagraph.local_complement(node)
        
        # Map out edges to zero
        self.map_metaneighbours_zero()
        
        # Return a new Metagraph
        NewMeta =  MetaGraphThree(G = self.Metagraph, M = self.Marginal)
        
        self.Metagraph = NewMeta.Metagraph
    
    #%% Info functions
    @property
    def metaneighbours_as_list(self):
        '''
        '''
        if self.Origingraphstate is None:
            raise ValueError("No original graphstate, so no original metaneighbours.")
        
        return [self.Metaneighours_as_dict['Na'],
                self.Metaneighours_as_dict['Nb'],
                self.Metaneighours_as_dict['Nc'],
                self.Metaneighours_as_dict['Nab'],
                self.Metaneighours_as_dict['Nbc'],
                self.Metaneighours_as_dict['Nac'],
                self.Metaneighours_as_dict['Nabc']]
        
    @property
    def metagraph_rank(self):
        '''
        The rank of the marginal, i.e. the rank of the metagraph in the original graph.
        '''
        return marginal_rank(self.Metagraph, M = (0,1,2))
    
    def get_number_of_populated_metaneighbours(self) -> int:
        '''
        Obtain the number of metaneighbours that are populated, i.e. that are connected to the marginal.
        '''
        nr_metaneighbours = 0
        
        for single in [3,4,5]:
            nr_metaneighbours += len(self.Metagraph.get_neighbourhood(single))
        for double in [6,7,8]:
            nr_metaneighbours += len(self.Metagraph.get_neighbourhood(double))/2
        nr_metaneighbours += len(self.Metagraph.get_neighbourhood(9))/3
        
        assert nr_metaneighbours == int(nr_metaneighbours), f"{nr_metaneighbours} is not an int."
        
        return int(nr_metaneighbours)
        
    #%% Drawing functions
    def draw(self, axis = None, fig = None, updateaxeslimits = True):
        '''
        Draw the metagraph in the given axis. If no axis is given, create a new figure and axis.
        Returns the figure and axis.
        '''
        if axis is None:
            fig, axis = prepare_graphstatedrawing(self.Graphstyle)
        
        if updateaxeslimits:
            xlim, ylim = calculate_axes_limits(self.Graphstyle)
            axis.set_xlim(xlim)
            axis.set_ylim(ylim)
        
        draw_nodes(Graphstyle = self.Graphstyle, axis = axis)
        
        draw_edges(Graphstate = self.Metagraph, Graphstyle = self.Graphstyle, axis = axis)
        
        return fig, axis
        
    #%% Init functions    
    def init_from_marginal_neighbours(self, N: list, Graphstyletemplate, labels):
        '''
        Obtain the 3-body Metagraph for a given list of neighbours of the marginal,
        i.e. Na, Nb and Nc, where these are the complete neighbourhoods.
        '''
        a_N = set(N[0])
        b_N = set(N[1])
        c_N = set(N[2])
        
        ab = 1 in a_N
        bc = 2 in b_N
        ac = 2 in a_N
        
        Na = a_N - b_N - c_N
        Nb = b_N.difference(a_N, c_N)
        Nc = c_N.difference(a_N, b_N)
        
        Nab = a_N & b_N - c_N
        Nbc = b_N & c_N - a_N
        Nac = a_N & c_N - b_N
        
        Nabc = a_N & b_N & c_N
        
        # First the inner edges
        identifier = ''.join(['1' if edge else '0' for edge in [ab,bc,ac]])
        
        # Then the outer edges
        identifier += ''.join(['1' if len(neigh) > 0 else '0' for neigh in [Na, Nb, Nc, Nab, Nbc, Nac, Nabc]])
        
        return self.init_from_identifier(identifier, Graphstyletemplate, labels)
        
    
    def init_from_identifier(self, identifier: str, Graphstyletemplate, labels):
        '''
        Obtain the 3-body marginal Metagraph from an identifier. See Metagraph.identifier for information.
        '''
        # Import
        from Graphstabilizer.graphs.metagraphs.tri import pos, potential_inner_edges, potential_single_edges, potential_double_edges, potential_triple_edges
        
        # Create an edgelist and fill based on the identifier
        edgelist = []
        
        # First the inner edges
        for i in range(3):
            # Inner edges
            if identifier[i] == '1':
                edgelist.append(potential_inner_edges[i])
            # Single edges
            if identifier[i+3] == '1':
                edgelist.append(potential_single_edges[i])
            # Double edges
            if identifier[i+6] == '1':
                edgelist.extend(potential_double_edges[i])
        
        # Triple edge
        if identifier[-1] == '1':
            edgelist.extend(potential_triple_edges[0])
    
        
        
        adj = get_AdjacencyMatrix_from_edgelist(10,edgelist)
        
        G = Graphstate(graph = adj)
        graphstyle = GraphStyle(nr_nodes = 10, template = Graphstyletemplate, node_labels = labels, node_positions = pos)
        return G, graphstyle
        
    
    def init_from_Graphstate(self, G: Graphstate, M: list, Graphstyletemplate, labels):
        '''
        Obtain the 3-body Metagraph for a given Graphstate on the marginal M containing 3 nodes of G.
        '''
        # Imports
        from Graphstabilizer.graphs.metagraphs.tri import potential_single_edges, potential_double_edges, potential_triple_edges, pos
        
        
        
        # Sort M in ascending order and get the complement C
        if type(M) == tuple:
            M = list(M)
        # M.sort()
        Mc = tuple(a for a in range(G.nr_qubits) if a not in M)
            
        # labels = [f'${M[0]}$',
        #           f'${M[1]}$',
        #           f'${M[2]}$',
        #           f'$N_{{{M[0]}}}$',
        #           f'$N_{{{M[1]}}}$',
        #           f'$N_{{{M[2]}}}$',
        #           f'$N_{{{M[0]},{M[1]}}}$',
        #           f'$N_{{{M[1]},{M[2]}}}$',
        #           f'$N_{{{M[0]},{M[2]}}}$',
        #           f'$N_{{{M[0]},{M[1]},{M[2]}}}$',
        #           ]
        
        # Initialize the meta neighbourhoods
        # a, b, c = [], [], []
        Na, Nb, Nc, Nab, Nac, Nbc, Nabc, Ne = [], [], [], [], [], [], [], []
        
        # Fill the meta neighbourhoods
        # First the inner nodes
        
        
        # Then the outer nodes
        for node in Mc:
            # row = G.adj.get_matrix()[ix_([node], M)]
            
            in_a = False
            in_b = False
            in_c = False
            
            
            if node in G.get_neighbourhood(M[0]):
                in_a = True
            if node in G.get_neighbourhood(M[1]):
                in_b = True
            if node in G.get_neighbourhood(M[2]):
                in_c = True
            
            
            
            if not in_a and not in_b and not in_c:
                Ne.append(node)
            elif in_a and not in_b and not in_c:
                Na.append(node)
            elif not in_a and in_b and not in_c:
                Nb.append(node)
            elif not in_a and not in_b and in_c:
                Nc.append(node)
            elif in_a and in_b and not in_c:
                Nab.append(node)
            elif in_a and not in_b and in_c:
                Nac.append(node)
            elif not in_a and in_b and in_c:
                Nbc.append(node)
            elif in_a and in_b and in_c:
                Nabc.append(node)
        
        
        # Obtain the edges of the metagraph
        edgelist = []
        # First the inner edges
        a_neighbourhood = G.get_neighbourhood(M[0])
        b_neighbourhood = G.get_neighbourhood(M[1])
        
        if M[1] in a_neighbourhood:
            edgelist.append((0,1))
        if M[2] in a_neighbourhood:
            edgelist.append((0,2))
        if M[2] in b_neighbourhood:
            edgelist.append((1,2))
    
        
        # Then the outer edges
        if len(Na) >= 1:
            edgelist.append(potential_single_edges[0])
        if len(Nb) >= 1:
            edgelist.append(potential_single_edges[1])
        if len(Nc) >= 1:
            edgelist.append(potential_single_edges[2])
        if len(Nab) >= 1:
            edgelist.extend(potential_double_edges[0])
        if len(Nbc) >= 1:
            edgelist.extend(potential_double_edges[1])
        if len(Nac) >= 1:
            edgelist.extend(potential_double_edges[2])
        if len(Nabc) >= 1:
            edgelist.extend(potential_triple_edges[0])
        
        # Create the metagraph
        adj = get_AdjacencyMatrix_from_edgelist(10,edgelist)
        
        G = Graphstate(graph = adj)
        graphstyle = GraphStyle(nr_nodes = 10, template = Graphstyletemplate, node_labels = labels, node_positions = pos)
        return G, graphstyle, {'Na' : Na, 'Nb' : Nb, 'Nc' : Nc, 'Nab' : Nab, 'Nac' : Nac, 'Nbc' : Nbc, 'Nabc' : Nabc, }
    
    #%% Info functions
    @property
    def identifier(self):
        '''
        Get the identifier for the metagraph. This is a 10-bit string, with every entry being 0 or 1 if that (meta)-edge is connected to or not.
        This starts with the internal edges, and subsequently the 7 outside neighbors are added.
        '''
        
        ## First the internal edges
        identifier = ['1' if edge else '0' for edge in [self.Metagraph.contains_edge(0,1), self.Metagraph.contains_edge(2,1), self.Metagraph.contains_edge(0,2)]]
        
        ## Then the external edges
        identifier.extend(['1' if len(self.Metagraph.get_neighbourhood(index)) >= 1 else '0' for index in range(3,10)])
        
        return ''.join(identifier)
    
#%% Four body metagraph
# class MetaGraphFour:
#     '''
#     Initialize a 4-body MetaGraph. It can be initialized from a given 
#     '''
#     def __init__(self, G, N, M: tuple = (0,1,2,3), Graphstyletemplate = metablackonwhite):
#         # If G is None we try to init from the N list
#         if G is None:
#             if N is None:
#                 raise ValueError("Provide either a Graphstate or a list of metaneighbours")
#             # Now N is a list
#             assert len(N) == 19, f"Metaneighbourlist {N} has {len(N)} entries which is not 19."
            
#             # The marginal is by default now [0,1,2,3]
#             self.Marginal = M
            
            
        
#         # Now G is a Graphstate so we initialize from this Graphstate
#         else:
#             assert len(M) == 4, f"Warning, provided marginal {M} has {len(M)} entries instead of 4."
#             for node in M:
#                 assert check_is_node_index(size = G.nr_qubits, node = node, raiseorFalse = 'false'), f"Warning, marginal {M} with entry {node} is not contained in graph G with {G.nr_qubits} nodes."
#             self.Metagraph, self.Metaneighours = self.init_from_Graphstate(G, M)
#             self.Marginal = M
        
        
#         self.Origingraphstate = G
        
#     #%% Meta-operations
#     def map_metaneighbours_zero(self):
#         '''
#         Remove all connections between outside metaneighbours that might have been created.
#         '''
#         A = self.Metagraph.adj.get_matrix()
#         A[ix_(range(4,19),range(4,19))] = zeros((15,15), dtype = 'int')
#         self.Metagraph = Graphstate(graph = AdjacencyMatrix(A), node_labels = self.Metagraph.node_labels, node_positions = self.Metagraph.node_positions, graphstyle = self.Metagraphstyle.graphstyle)
    
#     def local_complementation_internal(self, node):
#         '''
#         Perform a local complementation on the given internal node.
#         '''
#         assert node in [0,1,2,3], f"Warning, not an internal node given. Node provided is {node} but should be 0,1,2 or 3"
        
#         # Perform local complementation
#         self.Metagraph.local_complement(node)
        
#         # Map out edges to zero
#         self.map_metaneighbours_zero()
        
#         # Return a new Metagraph
#         NewMeta =  MetaGraphThree(G = self.Metagraph, M = self.Marginal)
        
#         self.Metagraph = NewMeta.Metagraph
        
    
#     #%% Init functions    
#     def init_from_metaneighbourlist(self, N: list):
#         '''
#         Obtain the 4-body Metagraph for a given list of metaneighbourhoods. This list is:
#             N = [a, b, c, d, Na, Nb, Nc, Nd, Nab, Nbc, Nac, Nabc]
            
#             Where 
#                 a, b, c are the internal neighbourhoods of node a, b and c as list of indexes
#                 Na, Nb, Nc are 
#         '''
#         raise NotImplementedError()
    
#     def init_from_Graphstate(self, G: Graphstate, M: list):
#         '''
#         Obtain the 3-body Metagraph for a given Graphstate on the marginal M containing 3 nodes of G.
#         '''
#         # Imports
#         from Graphstabilizer.graphs.metagraphs.tri import potential_single_edges, potential_double_edges, potential_triple_edges, labels, pos
        
        
        
#         # Sort M in ascending order and get the complement C
#         M.sort()
#         Mc = tuple(a for a in range(G.nr_qubits) if a not in M)
            
        
        
#         # Initialize the meta neighbourhoods
#         Na, Nb, Nc, Nab, Nac, Nbc, Nabc, Ne = [], [], [], [], [], [], [], []
        
#         # Fill the meta neighbourhoods
#         # First the inner nodes
        
#         # Then the outer nodes
#         for node in Mc:
            
#             n_string = ''.join([str(G.adj.get_matrix()[ix_([node], M)][0,i]) for i in range(3)])
            
            
#             if n_string == '000':
#                 Ne.append(node)
#             elif n_string == '100':
#                 Na.append(node)
#             elif n_string == '010':
#                 Nb.append(node)
#             elif n_string == '001':
#                 Nc.append(node)
#             elif n_string == '110':
#                 Nab.append(node)
#             elif n_string == '101':
#                 Nac.append(node)
#             elif n_string == '011':
#                 Nbc.append(node)
#             elif n_string == '111':
#                 Nabc.append(node)
        
#         # Obtain the edges of the metagraph
#         edgelist = []
#         # First the inner edges
#         a_neighbourhood = G.get_neighbourhood(M[0])
#         b_neighbourhood = G.get_neighbourhood(M[1])
        
#         if M[1] in a_neighbourhood:
#             edgelist.append((0,1))
#         if M[2] in a_neighbourhood:
#             edgelist.append((0,2))
#         if M[2] in b_neighbourhood:
#             edgelist.append((1,2))
    
        
#         # The the outer edges
#         if len(Na) >= 1:
#             edgelist.append(potential_single_edges[0])
#         if len(Nb) >= 1:
#             edgelist.append(potential_single_edges[1])
#         if len(Nc) >= 1:
#             edgelist.append(potential_single_edges[2])
#         if len(Nab) >= 1:
#             edgelist.extend(potential_double_edges[0])
#         if len(Nbc) >= 1:
#             edgelist.extend(potential_double_edges[1])
#         if len(Nac) >= 1:
#             edgelist.extend(potential_double_edges[2])
#         if len(Nabc) >= 1:
#             edgelist.extend(potential_triple_edges[0])
        
#         # Create the metagraph
#         adj = get_AdjacencyMatrix_from_edgelist(10,edgelist)
        
#         # G = Graphstate(graph = adj, node_labels = labels, node_positions = pos, graphstyle = Graphstyletemplate)
        
#         return G, {'Na' : Na, 'Nb' : Nb, 'Nc' : Nc, 'Nab' : Nab, 'Nac' : Nac, 'Nbc' : Nbc, 'Nabc' : Nabc, }

#%% General
def marginals_per_dimension(graphstate: Graphstate, marginalsize: int) -> list:
    '''
    For a given marginal size, return a list containing all marginals ordered per dimension, where the first element is a list of all marginals with dimension 0, the second element is a list of all marginals with dimension 1 etc.
    '''    
    assert marginalsize < graphstate.nr_qubits, f"There are no {marginalsize}-marginals for a state with {graphstate.nr_qubits} qubits."

    # Init empty list
    marginals_per_dimension = [[] for k in range(0, marginalsize + 1)]

    # Loop through every possible marginal selection, add 1 to the given rank counter.
    for marginal in combinations(iterable = range(graphstate.nr_qubits), r = marginalsize):
        marginals_per_dimension[marginal_dimension(graphstate, marginal)].append(marginal)

    return marginals_per_dimension
#%% Lists
def marginal_dimensiondict(graphstate: Graphstate, marginalsize: int) -> dict:
    '''
    For a given marginal size, return a dictionary with key, value pairs, where the keys are the possible dimensions, and the values are the number of marginals with that dimension.
    '''
    assert marginalsize < graphstate.nr_qubits, f"There are no {marginalsize}-marginals for a state with {graphstate.nr_qubits} qubits."
    
    # Init empty dictionary
    D = {}
    
    # Init all the possible ranks with 0 occurances
    for i in range(marginalsize + 1):
        D[i] = 0
    
    
    # Loop through every possible marginal selection, add 1 to the given rank counter.
    for marginal in combinations(iterable = range(graphstate.nr_qubits), r = marginalsize):
        D[marginal_dimension(graphstate, marginal)] += 1
    
    return D

def marginal_dimensionlist(graphstate: Graphstate, marginalsize: int) -> list:
    '''
    Return marginal_rankdict() as a list of only the values
    '''
    D = marginal_dimensiondict(graphstate, marginalsize)
    
    l = []
    for i in range(marginalsize + 1):
        l.append(D[i])
    return l


def marginal_dimensionsum(graphstate: Graphstate, marginalsize: int) -> int:
    '''
    Return the sum of the dimensions of all of the marginals of G with the given marginal size.
    '''
    return sum([d*n for d, n in marginal_dimensiondict(graphstate, marginalsize).items()])

def marginal_dimensionlistandsum(graphstate: Graphstate, marginalsize: int) -> tuple:
    '''
    Return the marginal dimension list and sum, see marginal_dimensionlist and marginal_dimensionsum
    Returns (l, s)
    '''
    D = marginal_dimensiondict(graphstate, marginalsize)
    
    l = []
    for i in range(marginalsize + 1):
        l.append(D[i])
    
    return l, sum([d*n for d, n in D.items()])
    
#%% Tensors
def marginal_tensor(graphstate: Graphstate, marginalsize: int, inv: str  = 'marginal_rank') -> ndarray:
    '''
    For a marginal size m, obtain the m-fold tensor with n TODO
    '''
    
    assert marginalsize < graphstate.nr_qubits, f"There are no {marginalsize}-marginals for a state with {graphstate.nr_qubits} qubits."
    
    T = zeros(shape = (graphstate.nr_qubits,)*marginalsize, dtype = 'int')
    
    
    # Loop through every possible marginal selection
    for marginal in combinations_with_replacement(iterable = range(graphstate.nr_qubits), r = marginalsize):
    # for marginal in combinations(iterable = range(graphstate.nr_qubits), r = marginalsize):

        # For this marginal, calculate the desired property
        if inv == 'marginal_rank':
            tensor_entry = marginal_rank(graphstate, marginal)
        elif inv == 'metaneighbourhood_size':
            if marginalsize == 3:
                meta = MetaGraphThree(G = graphstate, M = marginal)
                tensor_entry = meta.get_number_of_populated_metaneighbours()
        
        # Enter this in all the entries in the tensor associated with this marginal
        # These are exactly all the permutations of the marginal node list
        for index in permutations(iterable = marginal):
            T[index] = tensor_entry
    
    # Return the tensor
    return T

def metagraph_tensor(graphstate: Graphstate, metagraphgroups, indexing) -> ndarray:
    '''
    Calculate the tensor for a metagraph
    '''
    T = ones(shape = (graphstate.nr_qubits,)*3, dtype = 'int')
    # Loop through every possible marginal selection
    # for marginal in product(range(graphstate.nr_qubits), repeat = 3):
    #     if marginal[0] == marginal[1]:
    #         continue
    #     elif marginal[0] == marginal[2]:
    #         continue
    #     elif marginal[1] == marginal[2]:
    #         continue
    for M in combinations_with_replacement(range(graphstate.nr_qubits), r = 3):
        if len(set(M)) == 1:
            
            T[M] = 0
            # print(T)
            # break
        elif len(set(M)) == 2:
            for marginal in permutations(M):
                T[M] = int(log2(marginal_rank(graphstate, marginal)))
        else:
            for marginal in permutations(M):
                # Compute the metagraph and the identifier
                meta = MetaGraphThree(G = graphstate, M = marginal)
                identifier = meta.identifier
                
                # Loop through every group and check if the metagraph is in this group
                for groupnr, group in enumerate(metagraphgroups):
                    if identifier in group:
                        # Now add the resulting number in the tensor
                        T[marginal] = indexing[groupnr]
                        break
    
    # Return the tensor
    return T

def marginal_tensor_product(graphstate: Graphstate, marginalsize: int) -> float:
    '''
    TODO
    '''
    T = marginal_tensor(graphstate, marginalsize)
    
    if marginalsize == 2:
        eigs = npround(eigvalsh(T), decimals = 5)
    elif marginalsize == 3:
        eigs = npround(eigvalsh(sum(T)), decimals = 5)
    elif marginalsize == 4:
        eigs = npround(eigvalsh(sum(sum(T))), decimals = 5)
    elif marginalsize == 5:
        eigs = npround(eigvalsh(sum(sum(sum(T)))), decimals = 5)
    elif marginalsize == 6:
        eigs = npround(eigvalsh(sum(sum(sum(sum(T))))), decimals = 5)
    
    
    prod = prod_of_nonzero(eigs)
    
    return prod

#%% Measurement based invariants
def measured_invariant_tensor(graphstate: Graphstate, marginalsize: int) -> dict:
    '''
    '''
    out = {}
    
    for i in range(graphstate.size):
        # X
        GX = Graphstate(get_AdjacencyMatrix_from_edgelist(graphstate.size, graphstate.get_edgelist()))
        GX.X_measurement(i)
        
        prod = marginal_tensor_product(GX, marginalsize)
        
        
        if prod in out.keys():
            out[prod] += 1
        else:
            out[prod] = 1
        
        # Y
        GY = Graphstate(get_AdjacencyMatrix_from_edgelist(graphstate.size, graphstate.get_edgelist()))
        GY.Y_measurement(i)
        
        prod = marginal_tensor_product(GY, marginalsize)
        
        if prod in out.keys():
            out[prod] += 1
        else:
            out[prod] = 1
        
        # Z
        GZ = Graphstate(get_AdjacencyMatrix_from_edgelist(graphstate.size, graphstate.get_edgelist()))
        GZ.Z_measurement(i)
        
        prod = marginal_tensor_product(GZ, marginalsize)
        
        if prod in out.keys():
            out[prod] += 1
        else:
            out[prod] = 1
        
        
    return out

def measured_invariant_list(graphstate: Graphstate, marginalsize: int) -> dict:
    '''
    For a graphstate G, if a node is measured in a Pauli basis, the post-measurement state is a graphstate, or LC equivalent to a graph state. 
    In general, this post-measurement state is not from a constant class/orbit for different graphstates in the original graph state orbit.
    However, for a measurement of X, Y, Z on any given node, the 3-post measurement states will belong to 1,2 or 3 orbits/classes. This selection is LC invariant.
    This extends towards an X, Y, Z measurement on all the nodes together, for a total of 1 - 3n different orbits.
    This function calculates the marginal_dimensionlist of all 3n post-measurement states and returns a dict, 
    where the keys are the different options for the dimensionlist that are found, and the values are the number of occurances.
    '''
    out = {}
    
    for i in range(graphstate.size):
        # X
        GX = Graphstate(get_AdjacencyMatrix_from_edgelist(graphstate.size, graphstate.get_edgelist()))
        GX.X_measurement(i)
        
        TX = marginal_dimensionlist(GX, marginalsize)
        
        TX = ','.join([str(j) for j in TX])
        
        if TX in out.keys():
            out[TX] += 1
        else:
            out[TX] = 1
        
        # Y
        GY = Graphstate(get_AdjacencyMatrix_from_edgelist(graphstate.size, graphstate.get_edgelist()))
        GY.Y_measurement(i)
        
        TY = marginal_dimensionlist(GY, marginalsize)
        
        TY = ','.join([str(j) for j in TY])
        
        if TY in out.keys():
            out[TY] += 1
        else:
            out[TY] = 1
        
        # Z
        GZ = Graphstate(get_AdjacencyMatrix_from_edgelist(graphstate.size, graphstate.get_edgelist()))
        GZ.Z_measurement(i)
        
        TZ = marginal_dimensionlist(GZ, marginalsize)
        
        TZ = ','.join([str(j) for j in TZ])
        
        if TZ in out.keys():
            out[TZ] += 1
        else:
            out[TZ] = 1
        
        
    return out   

#%% Helper function
def prod_of_nonzero(iterable, precision = 0.001):
    running_prod = 1
    for entry in iterable:
        if abs(entry) > precision:
            running_prod *= entry
    return running_prod      