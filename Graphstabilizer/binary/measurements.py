# -*- coding: utf-8 -*-
"""
Created on Tue Mar 23 12:19:02 2021

@author: Jarnd
"""


## Global imports
from numpy import zeros, eye

## Local imports
from binary.linAlg import get_nullspace_basis
from binary.stabilizer import get_generator_matrix_from_generators
from binary.operators import get_X_bitvector_operators, get_Z_bitvector_operators

#%% Measurements
def perform_stabilizer_measurement(generators, measurement_indices, measurement_operators, delete_measured_nodes = True, diminished = False):
    '''
    Perform a measurement on the stabilizer state generated by the the generators provided. 
    All generators and measurement operators must be provided as a list of binary vectors.
    
    The measurement operators are all assumed to be linearily independent from each other.
    However, there may still be a linear dependence between the measurement operators and the generators combined.
    In this case, any of the measurement operators that is not linearily independent doesn't 'add' anything; 
    it already commutes with the generators/stabilizer state so a measurement of this operator is trivial and doesn't change the state.
    Thus, any such measurement post-measurement state is the same as just measuring the linearily independent meas. operators.
    
    A measurement of a list of m measurement operators on a stabilizer state can be seen as the solution to a linear system of equations.
    The post-measurement state is generated by a set of l = n-m generators, which are the l distinct linear combinations Ga_i,
       with G = [G1 G2...Gn] the generator matrix of the n generators G_i
       with a_i the l different solutions to the set of equations Ga = MPb + Xc + Zd
       
       with M = [M1 M2...Mm] the measurement matrix of the m measurement operators M_i
       with P the simplectic inner product matrix
       with X all single-qubit X operators on the non-measured nodes
       with Z all single-qubit Z operators on the non-measured nodes
       
    Alternatively, one can use a 'selector' matrix Lbar to only select the rows of G and M that correspond to the nodes that are measured.
    Then, the system of equations becomes LbarGa = LbarMb. Conversely, also define L as the 'complement' of Lbar in I
    
    In any case, the system is solved as the nullspace of the equation Lbar(G + MP)x = 0, with x = [a b] a length-(n+m) vector.
    
    Returns either the l updated generators with the measured nodes deleted, 
        or the l updated generators and the m measurement operators when they're not deleted.'
    '''
    ## Set some useful preliminary parameters
    n = int(len(generators[0])/2)
    m = len(measurement_indices)
    l = n - m
    
    ## Get the selector matrices
    L, Lbar = _get_selector_matrices(n, measurement_indices)
    
    ## Construct the matrix from which to obtain the nullspace basis
    if diminished:
        E = _get_diminished_E_matrix(n, generators, measurement_operators, Lbar)
    
    else:
        E = _get_full_E_matrix(n, generators, measurement_operators, measurement_indices)
    
    ## Solve for the nullspace of E
    null_basis, piv_columns = get_nullspace_basis(E, get_pivs = True)
    
    ## Check if the nullspace basis has more elements than it 'should' have.
    # Then, the measurement operators are not linearily independent with the generators
    if len(null_basis) > n - m:
        ## Print a warning
        print('Warning, overdetermined set of measurement operators. Trying to remove the dependent measurement operators. Expect a larger output state.')
        
        # Now we perform the measurement without the lin. dependent measurement operators
        measurement_indices_independent, measurement_operators_independent = _remove_dependent_measurement_operators(E, n, measurement_indices, piv_columns)
        
        # Now perform measurement with only the independent measurement operators
        return perform_stabilizer_measurement(generators, measurement_indices_independent, measurement_operators_independent, delete_measured_nodes = True, diminished = False)
    
    ## Obtain the generator matrix
    G = get_generator_matrix_from_generators(generators)
    
    ## Obtain a list of the new generators. The a_i's are the first n entries from the null basis vectors
    new_gens = [(G @ v[0:n,0]).T % 2 for v in null_basis]
    
    ## Return the new generators, either with the measured nodes deleted, or with the measured nodes intact; but then also return the meas.operators
    if delete_measured_nodes:
        return [L @ gen for gen in new_gens]
    else:
        return new_gens + measurement_operators

#%% Helper functions
def _get_selector_matrices(nr_qubits, measurement_indices):
    '''
    Get the selector matrices L and Lbar that select only the rows corresponding to the non-measured (L) or measured (Lbar) rows of a generator matrix.
    Returns a (2lx2n) matrix L and a (2mx2n) matrix M.
    '''
    # Init param
    m = len(measurement_indices)
    l = nr_qubits - m
    
    # Sort the measurement indices
    measurement_indices = list(measurement_indices)
    measurement_indices.sort()
        
    # Get the non-measured indices
    non_measured = [i for i in range(nr_qubits) if i not in measurement_indices]
    
    # Init L and Lbar
    L = zeros((2*l,2*nr_qubits), dtype = 'int')
    Lbar = zeros((2*m,2*nr_qubits), dtype = 'int')
    
    ## Loop through the measurement indices
    for measurement, index in enumerate(measurement_indices):
        Lbar[measurement, index] = Lbar[measurement + m, index + nr_qubits] = 1
    
    ## Loop through the non-measurement indices
    for nonmeas, index in enumerate(non_measured):
        L[nonmeas, index] = L[nonmeas + l, index + nr_qubits] = 1
    
    # Return both
    return L, Lbar

def _get_diminished_E_matrix(nr_qubits, generators, measurement_operators, Lbar):
    '''
    Get the diminished E matrix, which is the concatenations of the generators and the measurement operators,
    but only the measured nodes.
    '''
    ## Set m
    m = len(measurement_operators)
    
    # Init E
    E = zeros((2*nr_qubits,nr_qubits+m), dtype = 'int')
    
    # Put in the generators
    for i, gen in enumerate(generators):
        E[:,i:i+1] = gen
    
    # Put in the measurement operators, starting from the n-th column
    for i, op in enumerate(measurement_operators):
        E[:, [i + nr_qubits]] = op
    
    # Return
    return (Lbar @ E) % 2

def _get_full_E_matrix(nr_qubits, generators, measurement_operators, measurement_indices):
    '''
    Get the full E matrix, which is the concatenations of the generators, measurement operators,
    and an X and Z operators on the non-measured nodes.
    '''
    ## Set m
    m = len(measurement_operators)
    
    ## Get non-measured nodes
    non_measured_indices = [i for i in range(nr_qubits) if i not in measurement_indices]
    
    ## Get the non-measured node operators
    Xs = get_X_bitvector_operators(non_measured_indices, nr_qubits)
    Zs = get_Z_bitvector_operators(non_measured_indices, nr_qubits)
    
    ## Init E
    E = zeros((2*nr_qubits, 3*nr_qubits - m ), dtype = 'int')
    
    # Put in the generators
    for i, gen in enumerate(generators):
        E[:,i:i+1] = gen
    
    # Put in the measurement operators, starting from the n-th column
    for i, op in enumerate(measurement_operators):
        E[:, [i + nr_qubits]] = op
    
    # Put in the non-measurement operators
    for i, ops in enumerate(zip(Xs, Zs)):
        E[:, [nr_qubits + m + 2*i]] = ops[0]
        E[:, [nr_qubits + m + 2*i + 1]] = ops[1]
        
    # Return
    return E

def _remove_dependent_measurement_operators(E, n, measurement_indices, piv_columns):
    '''
    Remove the measurement operators from E which are linearly dependent on the other operators and the generators of the original state.
    These are exactly the non-pivot positions in the range n - n + m
    Returns the new measurement indices and measurement operators
    '''
    ## Get the number of original operators
    m = len(measurement_indices)
    
    ## Get the original operators
    measurement_operators_original = []
    for operator_index in range(n, n + m):
        measurement_operators_original.append(E[:,[operator_index]])
    
    ## Get the indices of only the independent measurement operators columns in E
    measurement_operators_indices_independent = [i for i in range(n,n + m) if i in piv_columns]
    
    ## Get the indipendent measurement operators
    measurement_operators_independent = []
    
    for index in measurement_operators_indices_independent:
        measurement_operators_independent.append(E[:,[index]])
    
    ## Get the indices of the indepentent measurement operators
    measurement_indices_independent = [measurement_indices[i] for i in range(m) if i + n in piv_columns]
    
    ## Return the independent measurement indices and operators
    return measurement_indices_independent, measurement_operators_independent